const mongoose = require('mongoose');

// Generated by Copilot
const commentSchema = new mongoose.Schema({
  content: {
    type: String,
    required: [true, 'Comment content is required'],
    trim: true,
    maxlength: [2000, 'Comment cannot be more than 2000 characters']
  },
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  task: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Task',
    default: null
  },
  project: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Project',
    default: null
  },
  parentComment: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Comment',
    default: null
  },
  mentions: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  attachments: [{
    filename: String,
    originalName: String,
    mimetype: String,
    size: Number,
    url: String,
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  reactions: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    emoji: {
      type: String,
      enum: ['👍', '👎', '❤️', '😄', '😮', '😢', '😡']
    },
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  isEdited: {
    type: Boolean,
    default: false
  },
  editHistory: [{
    content: String,
    editedAt: {
      type: Date,
      default: Date.now
    }
  }],
  isDeleted: {
    type: Boolean,
    default: false
  },
  deletedAt: {
    type: Date,
    default: null
  },
  deletedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
commentSchema.index({ task: 1, createdAt: -1 });
commentSchema.index({ project: 1, createdAt: -1 });
commentSchema.index({ author: 1, createdAt: -1 });
commentSchema.index({ parentComment: 1 });
commentSchema.index({ mentions: 1 });
commentSchema.index({ isDeleted: 1 });

// Virtual for replies (nested comments)
commentSchema.virtual('replies', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'parentComment'
});

// Parse mentions from content before saving
commentSchema.pre('save', function(next) {
  if (!this.isModified('content')) return next();
  
  // Extract mentions (@username) from content
  const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;
  const mentions = [];
  let match;
  
  while ((match = mentionRegex.exec(this.content)) !== null) {
    const userId = match[2];
    if (mongoose.Types.ObjectId.isValid(userId)) {
      mentions.push(userId);
    }
  }
  
  this.mentions = [...new Set(mentions)]; // Remove duplicates
  next();
});

// Add reaction to comment
commentSchema.methods.addReaction = function(userId, emoji) {
  // Remove existing reaction from same user
  this.reactions = this.reactions.filter(reaction => 
    reaction.user.toString() !== userId.toString()
  );
  
  // Add new reaction
  this.reactions.push({
    user: userId,
    emoji,
    createdAt: new Date()
  });
};

// Remove reaction from comment
commentSchema.methods.removeReaction = function(userId) {
  this.reactions = this.reactions.filter(reaction => 
    reaction.user.toString() !== userId.toString()
  );
};

// Edit comment (save to history)
commentSchema.methods.editContent = function(newContent) {
  // Save current content to history
  if (this.content !== newContent) {
    this.editHistory.push({
      content: this.content,
      editedAt: new Date()
    });
    
    this.content = newContent;
    this.isEdited = true;
  }
};

// Soft delete comment
commentSchema.methods.softDelete = function(userId) {
  this.isDeleted = true;
  this.deletedAt = new Date();
  this.deletedBy = userId;
  this.content = '[This comment has been deleted]';
};

// Check if user can edit/delete comment
commentSchema.methods.canModify = function(userId) {
  return this.author.toString() === userId.toString();
};

// Get reaction counts
commentSchema.virtual('reactionCounts').get(function() {
  const counts = {};
  
  this.reactions.forEach(reaction => {
    counts[reaction.emoji] = (counts[reaction.emoji] || 0) + 1;
  });
  
  return counts;
});

// Check if user has reacted
commentSchema.methods.hasUserReacted = function(userId) {
  return this.reactions.some(reaction => 
    reaction.user.toString() === userId.toString()
  );
};

// Get user's reaction
commentSchema.methods.getUserReaction = function(userId) {
  const reaction = this.reactions.find(reaction => 
    reaction.user.toString() === userId.toString()
  );
  return reaction ? reaction.emoji : null;
};

module.exports = mongoose.model('Comment', commentSchema);
