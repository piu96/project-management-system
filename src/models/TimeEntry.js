const mongoose = require('mongoose');

// Generated by Copilot
const timeEntrySchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  task: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Task',
    required: true
  },
  project: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Project',
    required: true
  },
  workspace: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Workspace',
    required: true
  },
  description: {
    type: String,
    trim: true,
    maxlength: [500, 'Description cannot be more than 500 characters']
  },
  hours: {
    type: Number,
    required: [true, 'Hours is required'],
    min: [0.1, 'Minimum time entry is 0.1 hours (6 minutes)'],
    max: [24, 'Maximum time entry is 24 hours per day']
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  startTime: {
    type: Date,
    default: null
  },
  endTime: {
    type: Date,
    default: null
  },
  isRunning: {
    type: Boolean,
    default: false
  },
  category: {
    type: String,
    enum: ['development', 'design', 'testing', 'meeting', 'documentation', 'research', 'bug_fixing', 'review', 'other'],
    default: 'development'
  },
  billable: {
    type: Boolean,
    default: true
  },
  hourlyRate: {
    type: Number,
    default: 0,
    min: 0
  },
  cost: {
    type: Number,
    default: 0,
    min: 0
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  approved: {
    isApproved: {
      type: Boolean,
      default: false
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null
    },
    approvedAt: {
      type: Date,
      default: null
    },
    rejectionReason: {
      type: String,
      default: null
    }
  },
  invoice: {
    invoiceId: {
      type: String,
      default: null
    },
    invoiced: {
      type: Boolean,
      default: false
    },
    invoicedAt: {
      type: Date,
      default: null
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
timeEntrySchema.index({ user: 1, date: -1 });
timeEntrySchema.index({ workspace: 1, date: -1 });
timeEntrySchema.index({ project: 1, date: -1 });
timeEntrySchema.index({ task: 1, date: -1 });
timeEntrySchema.index({ date: 1, user: 1 });
timeEntrySchema.index({ billable: 1, 'approved.isApproved': 1 });
timeEntrySchema.index({ 'invoice.invoiced': 1 });
timeEntrySchema.index({ isRunning: 1 });

// Calculate cost before saving
timeEntrySchema.pre('save', function(next) {
  if (this.isModified('hours') || this.isModified('hourlyRate')) {
    this.cost = this.hours * this.hourlyRate;
  }
  
  // If end time is set and start time exists, calculate hours
  if (this.endTime && this.startTime && this.isModified('endTime')) {
    const diffMs = this.endTime - this.startTime;
    const diffHours = diffMs / (1000 * 60 * 60);
    this.hours = Math.round(diffHours * 100) / 100; // Round to 2 decimal places
    this.isRunning = false;
  }
  
  next();
});

// Start timer
timeEntrySchema.methods.startTimer = function() {
  this.startTime = new Date();
  this.isRunning = true;
  this.endTime = null;
};

// Stop timer
timeEntrySchema.methods.stopTimer = function() {
  if (this.startTime && this.isRunning) {
    this.endTime = new Date();
    this.isRunning = false;
    
    const diffMs = this.endTime - this.startTime;
    const diffHours = diffMs / (1000 * 60 * 60);
    this.hours = Math.round(diffHours * 100) / 100;
  }
};

// Approve time entry
timeEntrySchema.methods.approve = function(approvedBy) {
  this.approved.isApproved = true;
  this.approved.approvedBy = approvedBy;
  this.approved.approvedAt = new Date();
  this.approved.rejectionReason = null;
};

// Reject time entry
timeEntrySchema.methods.reject = function(reason, rejectedBy) {
  this.approved.isApproved = false;
  this.approved.approvedBy = rejectedBy;
  this.approved.approvedAt = new Date();
  this.approved.rejectionReason = reason;
};

// Mark as invoiced
timeEntrySchema.methods.markInvoiced = function(invoiceId) {
  this.invoice.invoiced = true;
  this.invoice.invoiceId = invoiceId;
  this.invoice.invoicedAt = new Date();
};

// Virtual for duration in different formats
timeEntrySchema.virtual('duration').get(function() {
  const totalMinutes = Math.round(this.hours * 60);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  
  return {
    hours: this.hours,
    formatted: `${hours}h ${minutes}m`,
    totalMinutes,
    decimal: this.hours
  };
});

// Check if entry is editable (within same day and not approved)
timeEntrySchema.virtual('isEditable').get(function() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const entryDate = new Date(this.date);
  entryDate.setHours(0, 0, 0, 0);
  
  return entryDate >= today && !this.approved.isApproved && !this.invoice.invoiced;
});

// Static method to get user's total hours for a period
timeEntrySchema.statics.getUserTotalHours = async function(userId, startDate, endDate) {
  const result = await this.aggregate([
    {
      $match: {
        user: mongoose.Types.ObjectId(userId),
        date: { $gte: startDate, $lte: endDate }
      }
    },
    {
      $group: {
        _id: null,
        totalHours: { $sum: '$hours' },
        totalCost: { $sum: '$cost' },
        billableHours: {
          $sum: {
            $cond: ['$billable', '$hours', 0]
          }
        },
        approvedHours: {
          $sum: {
            $cond: ['$approved.isApproved', '$hours', 0]
          }
        }
      }
    }
  ]);
  
  return result.length > 0 ? result[0] : {
    totalHours: 0,
    totalCost: 0,
    billableHours: 0,
    approvedHours: 0
  };
};

// Static method to get project time summary
timeEntrySchema.statics.getProjectTimeSummary = async function(projectId, startDate, endDate) {
  const match = { project: mongoose.Types.ObjectId(projectId) };
  if (startDate && endDate) {
    match.date = { $gte: startDate, $lte: endDate };
  }
  
  const result = await this.aggregate([
    { $match: match },
    {
      $group: {
        _id: '$user',
        totalHours: { $sum: '$hours' },
        totalCost: { $sum: '$cost' },
        billableHours: {
          $sum: {
            $cond: ['$billable', '$hours', 0]
          }
        }
      }
    },
    {
      $lookup: {
        from: 'users',
        localField: '_id',
        foreignField: '_id',
        as: 'user'
      }
    },
    {
      $unwind: '$user'
    },
    {
      $project: {
        _id: 1,
        totalHours: 1,
        totalCost: 1,
        billableHours: 1,
        'user.name': 1,
        'user.email': 1
      }
    }
  ]);
  
  return result;
};

module.exports = mongoose.model('TimeEntry', timeEntrySchema);
